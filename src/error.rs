use crate::entity;
use actix_http::{
    body::BoxBody,
    header::{self, ToStrError},
    Response, StatusCode,
};
use actix_web::{web::BytesMut, HttpResponse, ResponseError};
use std::fmt::{Debug, Display, Formatter};

#[derive(Debug)]
pub enum Error {
    FailedToMatchAnyContentType,
    PayloadTooLarge(String),
    FailedToMapHeaderToStr(ToStrError),
    SerializationDeserializationError(simple_serde::Error),
    PayloadError(entity::payload_error::PayloadError),
    FailedToGetContentTypeFromHeader,
    Infallible,
    NoPayloadSizeDefinitionInHeader,
    FailedToParseToInt(std::num::ParseIntError),
}

unsafe impl Send for Error {}
unsafe impl Sync for Error {}

impl From<entity::payload_error::PayloadError> for Error {
    fn from(e: entity::payload_error::PayloadError) -> Self {
        Self::PayloadError(e)
    }
}

impl From<ToStrError> for Error {
    fn from(e: ToStrError) -> Self {
        Self::FailedToMapHeaderToStr(e)
    }
}

impl From<simple_serde::Error> for Error {
    fn from(e: simple_serde::Error) -> Self {
        Self::SerializationDeserializationError(e)
    }
}

impl From<std::convert::Infallible> for Error {
    fn from(_: std::convert::Infallible) -> Self {
        Self::Infallible
    }
}

impl From<std::num::ParseIntError> for Error {
    fn from(e: std::num::ParseIntError) -> Self {
        Self::FailedToParseToInt(e)
    }
}

impl Display for Error {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::FailedToMatchAnyContentType => write!(f, "Failed to match any content type"),
            Error::PayloadTooLarge(i) => write!(f, "Payload is too large: {}", i),
            Error::FailedToMapHeaderToStr(e) => write!(f, "Failed to map Header Value to Str: {}", e),
            Error::SerializationDeserializationError(e) => {
                write!(f, "Serialization/Deserialization error: {:?}", e)
            }
            Error::PayloadError(e) => write!(f, "Payload Error: {:?}", e),
            Error::FailedToGetContentTypeFromHeader => write!(f, "FailedToGetContentTypeFromHeader"),
            Error::Infallible => write!(f, "Infallible - you should never end up here!! - Please open a bug with a stacktrace using RUST_BACKTRACE=full"),
            Error::NoPayloadSizeDefinitionInHeader => write!(f, "NoPayloadSizeDefinitionInHeader"),
            Error::FailedToParseToInt(_) => write!(f, "FailedToParseToInt"),
        }
    }
}

impl ResponseError for Error {
    fn status_code(&self) -> StatusCode {
        StatusCode::INTERNAL_SERVER_ERROR
    }

    /// Create response for error
    ///
    /// Internal server error is generated by default.
    fn error_response(&self) -> actix_web::HttpResponse {
        let mut resp = Response::new(self.status_code());
        let buf = BytesMut::new();
        resp.headers_mut().insert(
            header::CONTENT_TYPE,
            header::HeaderValue::from_static("text/plain; charset=utf-8"),
        );
        HttpResponse::from(resp.set_body(BoxBody::new(buf)))
    }
}

#[cfg(test)]
mod test {
    use crate::Error;

    use actix_http::{
        body::BoxBody,
        header::{self},
        Response, StatusCode,
    };
    use actix_web::{web::BytesMut, HttpResponse, ResponseError};

    #[test]
    fn default_error_code() {
        let err = Error::Infallible;
        assert_eq!(err.status_code(), StatusCode::INTERNAL_SERVER_ERROR);
    }
    #[test]
    fn default_error_response() {
        let err = Error::Infallible;

        let mut resp = Response::new(StatusCode::INTERNAL_SERVER_ERROR);
        let mut buf = BytesMut::new();
        resp.headers_mut().insert(
            header::CONTENT_TYPE,
            header::HeaderValue::from_static("text/plain; charset=utf-8"),
        );

        assert_eq!(
            format!("{:?}", err.error_response()),
            format!("{:?}", HttpResponse::from(resp.set_body(BoxBody::new(buf))))
        );
    }
}
